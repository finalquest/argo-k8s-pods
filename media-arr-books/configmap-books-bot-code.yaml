apiVersion: v1
kind: ConfigMap
metadata:
  name: books-bot-code
  namespace: media
data:
  index.js: |
    import TelegramBot from 'node-telegram-bot-api';
    import pino from 'pino';
    import { MeiliSearch } from 'meilisearch';
    import * as fs from 'fs';
    import nodemailer from 'nodemailer';

    const logger = pino({ level: process.env.LOG_LEVEL || 'info' });

    const {
      TELEGRAM_BOT_TOKEN,
      ALLOWED_USER_IDS = '',
      MEILI_HOST,
      MEILI_INDEX = 'biblioteca',
      BIBLIOTECA_BASE_URL,
      MEILI_API_KEY,
      LOG_LEVEL = 'info',
      SMTP_HOST,
      SMTP_PORT,
      SMTP_EMAIL,
      SMTP_PASSWORD,
      SMTP_FROM
    } = process.env;

    if (!TELEGRAM_BOT_TOKEN) {
      logger.error('Missing TELEGRAM_BOT_TOKEN');
      process.exit(1);
    }

    if (!MEILI_HOST) {
      logger.error('Missing MEILI_HOST');
      process.exit(1);
    }

    const allowedUsers = new Set(
      ALLOWED_USER_IDS.split(',')
        .map((id) => id.trim())
        .filter(Boolean)
    );

    const meiliClient = new MeiliSearch({
      host: MEILI_HOST,
      apiKey: MEILI_API_KEY,
    });

    const EMAILS_FILE = '/data/bot-emails.json';

    const loadEmails = () => {
      try {
        if (fs.existsSync(EMAILS_FILE)) {
          const data = fs.readFileSync(EMAILS_FILE, 'utf-8');
          return JSON.parse(data);
        }
      } catch (err) {
        logger.error({ err }, 'Error loading emails file');
      }
      return {};
    };

    const saveEmails = (emails) => {
      try {
        fs.writeFileSync(EMAILS_FILE, JSON.stringify(emails, null, 2));
        logger.info('Emails saved successfully');
      } catch (err) {
        logger.error({ err }, 'Error saving emails file');
        throw err;
      }
    };

    const isValidEmail = (email) => {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    };

    const sanitizeFilename = (text) => {
      return text.replace(/[<>:"/\\|?*]/g, '');
    };

    const generateFilename = (title, authors) => {
      let authorStr = 'Desconocido';
      if (Array.isArray(authors) && authors.length > 0) {
        authorStr = authors[0];
      } else if (typeof authors === 'string' && authors.length > 0) {
        authorStr = authors;
      }
      const sanitizedTitle = sanitizeFilename(title);
      const sanitizedAuthor = sanitizeFilename(authorStr);
      return `${sanitizedTitle} - ${sanitizedAuthor}.epub`;
    };

    const truncate = (text, maxLength = 280) => {
      if (!text || text.length <= maxLength) return text || '';
      return text.substring(0, maxLength - 3) + '...';
    };

    const formatResult = (hit) => {
      const authors = Array.isArray(hit.authors) ? hit.authors.join(', ') : hit.authors || 'Desconocido';
      const year = hit.published ? `(${hit.published})` : '';
      const description = truncate(hit.description, 280);

      return `${hit.title} ${year}\nAutor: ${authors}\n\n${description}`;
    };

    const buildInlineKeyboard = (results, userId) => {
      const emails = loadEmails();
      const hasEmail = emails[userId];

      const keyboard = results.map((hit, index) => {
        const row = [
          {
            text: `üì• ${index + 1}. ${truncate(hit.title, 40)}`,
            callback_data: `download_${hit.libid}`
          },
          {
            text: '‚ÑπÔ∏è Info',
            callback_data: `info_${hit.libid}`
          }
        ];

        if (hasEmail) {
          row.push({
            text: 'üìß Email',
            callback_data: `email_${hit.libid}`
          });
        }

        return row;
      });

      return { inline_keyboard: keyboard };
    };

    const searchMeilisearch = async (query, limit = 5) => {
      try {
        const index = meiliClient.index(MEILI_INDEX);
        const search = await index.search(query, {
          limit,
          attributesToRetrieve: ['libid', 'title', 'authors', 'description', 'published', 'filename'],
        });

        return search.hits;
      } catch (err) {
        logger.error({ err, query }, 'Error searching Meilisearch');
        throw err;
      }
    };

    const getBookById = async (libid) => {
      try {
        const index = meiliClient.index(MEILI_INDEX);
        const result = await index.getDocument(String(libid), {
          fields: ['libid', 'title', 'authors', 'description', 'published', 'filename', 'pagecount', 'size', 'labels']
        });
        return result;
      } catch (err) {
        logger.error({ err, libid }, 'Error getting book by ID');
        return null;
      }
    };

    const sendEmail = async (toEmail, book, epubBuffer, filename) => {
      try {
        const transporter = nodemailer.createTransport({
          host: SMTP_HOST || 'smtp.gmail.com',
          port: SMTP_PORT || 587,
          secure: false,
          auth: {
            user: SMTP_EMAIL,
            pass: SMTP_PASSWORD
          }
        });

        const authors = Array.isArray(book.authors) ? book.authors.join(', ') : book.authors || 'Desconocido';
        const subject = `üìö ${book.title} - ${authors}`;

        const mailOptions = {
          from: SMTP_FROM || SMTP_EMAIL,
          to: toEmail,
          subject: subject,
          text: `Hola,

          Aqu√≠ tienes el libro que pediste:

          üìö T√≠tulo: ${book.title}
          ‚úçÔ∏è Autor(es): ${authors}
          üìÖ A√±o: ${book.published || 'N/A'}
          üìÑ P√°ginas: ${book.pagecount || 'N/A'}
          üíæ Tama√±o: ${book.size ? `${(book.size / 1024 / 1024).toFixed(2)} MB` : 'N/A'}

          El archivo EPUB est√° adjunto.

          ¬°Saludos!`,
          attachments: [{
            filename: filename,
            content: epubBuffer
          }]
        };

        await transporter.sendMail(mailOptions);
        logger.info({ toEmail, title: book.title }, 'Email sent successfully');
        return true;
      } catch (err) {
        logger.error({ err, toEmail }, 'Error sending email');
        throw err;
      }
    };

    async function startBot() {
      const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });
      logger.info('Bot connected to Telegram');

      bot.on('message', async (msg) => {
        const chatId = msg.chat.id;
        const userId = msg.from?.id ? String(msg.from.id) : '';

        if (allowedUsers.size && !allowedUsers.has(userId)) {
          logger.warn({ userId }, 'Unauthorized user');
          return;
        }

        const text = msg.text?.trim();
        if (!text) {
          bot.sendMessage(chatId, 'Por favor, env√≠a un texto para buscar libros.');
          return;
        }

        if (text.startsWith('/')) {
          if (text === '/start') {
            bot.sendMessage(chatId, 'üìö ¬°Hola! Soy el buscador de la Biblioteca Secreta.\n\nEnv√≠a el t√≠tulo o autor de un libro y buscar√© en la biblioteca local de 152,080 EPUBs.\n\nComandos disponibles:\n/addMail <email> - Asocia un email para recibir libros por correo');
          } else if (text === '/help') {
            bot.sendMessage(chatId, 'üìö Biblioteca Secreta Bot\n\n‚Ä¢ Env√≠a un texto para buscar libros\n‚Ä¢ Usa los botones para descargar o ver m√°s info\n‚Ä¢ Resultados limitados a 5 por b√∫squeda\n‚Ä¢ Los EPUBs se env√≠an como archivos (funciona desde cualquier red)\n‚Ä¢ Usa /addMail <email> para recibir libros por correo electr√≥nico\n\nComandos:\n/addMail <email> - Asocia un email a tu cuenta');
          } else if (text.startsWith('/addMail')) {
            const email = text.replace('/addMail', '').trim();

            if (!email) {
              bot.sendMessage(chatId, '‚ùå Por favor, incluye un email.\n\nUso: /addMail tu@email.com');
              return;
            }

            if (!isValidEmail(email)) {
              bot.sendMessage(chatId, '‚ùå El email no tiene un formato v√°lido.\n\nUso: /addMail tu@email.com');
              return;
            }

            const emails = loadEmails();
            emails[userId] = email;
            saveEmails(emails);

            bot.sendMessage(chatId, `‚úÖ Email asociado correctamente:\n\nüìß ${email}\n\nAhora puedes usar el bot√≥n üìß Email en los resultados para recibir libros en este correo.`);
          } else {
            bot.sendMessage(chatId, 'Comando no reconocido. Env√≠a un texto para buscar libros.');
          }
          return;
        }

        try {
          logger.info({ chatId, text }, 'Searching for books');
          const results = await searchMeilisearch(text);

          if (results.length === 0) {
            bot.sendMessage(chatId, `üîç No encontr√© resultados para "${text}".\n\nIntenta con otro t√©rmino de b√∫squeda.`);
            return;
          }

          const messageText = `üìö Resultados para "${text}":\n\n` +
            results.map((hit, i) => `${i + 1}. ${formatResult(hit)}`).join('\n\n---\n\n');

          await bot.sendMessage(chatId, messageText, {
            disable_web_page_preview: true,
            reply_markup: buildInlineKeyboard(results, userId)
          });
        } catch (err) {
          logger.error({ chatId, err }, 'Error processing search');
          bot.sendMessage(chatId, `‚ùå Error al buscar: ${err.message}`);
        }
      });

      bot.on('callback_query', async (query) => {
        const chatId = query.message.chat.id;
        const userId = query.from?.id ? String(query.from.id) : '';

        if (allowedUsers.size && !allowedUsers.has(userId)) {
          bot.answerCallbackQuery(query.id, { text: 'No autorizado' });
          return;
        }

        try {
          if (query.data.startsWith('download_')) {
            const libid = query.data.replace('download_', '');
            const book = await getBookById(libid);

            if (!book || !book.filename) {
              bot.answerCallbackQuery(query.id, { text: 'Libro no encontrado' });
              return;
            }

            const downloadUrl = `${BIBLIOTECA_BASE_URL}/biblioteca/${book.filename}`;

            logger.info({ libid, filename: book.filename, title: book.title, authors: book.authors }, 'Sending EPUB from NAS...');

            try {
              const response = await fetch(downloadUrl);
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }
              const arrayBuffer = await response.arrayBuffer();
              const buffer = Buffer.from(arrayBuffer);
              const filename = generateFilename(book.title, book.authors);

              if (!fs.existsSync('/tmp')) {
                fs.mkdirSync('/tmp');
              }

              const tempPath = `/tmp/${filename}`;
              fs.writeFileSync(tempPath, buffer);

              logger.info({ libid, filename }, 'Archivo temporal guardado');

              await bot.sendDocument(chatId, tempPath, {
                caption: `üì• ${book.title}\n‚úçÔ∏è ${Array.isArray(book.authors) ? book.authors.join(', ') : book.authors}`,
              });

              bot.answerCallbackQuery(query.id, { text: '‚úÖ Archivo temporal enviado' });
            } catch (fetchError) {
              logger.error({ err: fetchError, url: downloadUrl }, 'Error downloading or saving EPUB');
              bot.sendMessage(chatId, `‚ùå Error al descargar o guardar archivo temporal: ${fetchError.message}`);
              bot.answerCallbackQuery(query.id, { text: '‚ùå Error al descargar o guardar' });
            }
          } else if (query.data.startsWith('info_')) {
            const libid = query.data.replace('info_', '');
            const book = await getBookById(libid);

            if (!book) {
              bot.answerCallbackQuery(query.id, { text: 'Libro no encontrado' });
              return;
            }

            const authors = Array.isArray(book.authors) ? book.authors.join(', ') : book.authors || 'Desconocido';
            const labels = Array.isArray(book.labels) ? book.labels.join(', ') : book.labels || 'N/A';
            const downloadUrl = `${BIBLIOTECA_BASE_URL}/biblioteca/${book.filename}`;

            const infoText = `üìñ Detalles del libro\n\n` +
              `üìö T√≠tulo: ${book.title}\n` +
              `‚úçÔ∏è Autor(es): ${authors}\n` +
              `üìÖ A√±o: ${book.published || 'N/A'}\n` +
              `üìÑ P√°ginas: ${book.pagecount || 'N/A'}\n` +
              `üíæ Tama√±o: ${book.size ? `${(book.size / 1024 / 1024).toFixed(2)} MB` : 'N/A'}\n` +
              `üè∑Ô∏è Etiquetas: ${labels}\n\n` +
              `üì• ${downloadUrl}`;

            await bot.sendMessage(chatId, infoText, {
              disable_web_page_preview: true
            });
            bot.answerCallbackQuery(query.id, { text: '‚ÑπÔ∏è Detalles mostrados' });
          } else if (query.data.startsWith('email_')) {
            const libid = query.data.replace('email_', '');
            const book = await getBookById(libid);

            if (!book || !book.filename) {
              bot.answerCallbackQuery(query.id, { text: 'Libro no encontrado' });
              return;
            }

            const emails = loadEmails();
            const userEmail = emails[userId];

            if (!userEmail) {
              bot.answerCallbackQuery(query.id, { text: '‚ùå No tienes email configurado' });
              bot.sendMessage(chatId, '‚ùå No tienes un email configurado.\n\nUsa el comando:\n/addMail tu@email.com\n\npara asociar un email a tu cuenta.');
              return;
            }

            try {
              bot.answerCallbackQuery(query.id, { text: 'üìß Preparando env√≠o por email...' });

              const downloadUrl = `${BIBLIOTECA_BASE_URL}/biblioteca/${book.filename}`;
              logger.info({ libid, filename: book.filename, userEmail }, 'Downloading EPUB for email...');

              const response = await fetch(downloadUrl);
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }

              const arrayBuffer = await response.arrayBuffer();
              const epubBuffer = Buffer.from(arrayBuffer);
              const filename = generateFilename(book.title, book.authors);

              await sendEmail(userEmail, book, epubBuffer, filename);

              bot.sendMessage(chatId, `‚úÖ Libro enviado a:\n\nüìß ${userEmail}\n\nüìö ${book.title}`);
            } catch (emailError) {
              logger.error({ err: emailError, userId, libid }, 'Error sending email');
              bot.sendMessage(chatId, `‚ùå Error al enviar por email: ${emailError.message}`);
            }
          }
        } catch (err) {
          logger.error({ chatId, err }, 'Error processing callback query');
          bot.answerCallbackQuery(query.id, { text: 'Error al procesar' });
        }
      });

      bot.on('polling_error', (err) => {
        logger.warn({ err }, 'Polling error');
      });

      logger.info('Bot ready to receive messages');
    }

    startBot().catch((err) => {
      logger.error({ err }, 'Bot failed to start');
      process.exit(1);
    });
