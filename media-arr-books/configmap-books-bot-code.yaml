apiVersion: v1
kind: ConfigMap
metadata:
  name: books-bot-code
  namespace: media
data:
  index.js: |
    import TelegramBot from 'node-telegram-bot-api';
    import pino from 'pino';
    import { MeiliSearch } from 'meilisearch';
    import * as fs from 'fs';
    
    const logger = pino({ level: process.env.LOG_LEVEL || 'info' });
    
    const {
      TELEGRAM_BOT_TOKEN,
      ALLOWED_USER_IDS = '',
      MEILI_HOST,
      MEILI_INDEX = 'biblioteca',
      BIBLIOTECA_BASE_URL,
      MEILI_API_KEY,
      LOG_LEVEL = 'info'
    } = process.env;
    
    if (!TELEGRAM_BOT_TOKEN) {
      logger.error('Missing TELEGRAM_BOT_TOKEN');
      process.exit(1);
    }
    
    if (!MEILI_HOST) {
      logger.error('Missing MEILI_HOST');
      process.exit(1);
    }
    
    const allowedUsers = new Set(
      ALLOWED_USER_IDS.split(',')
        .map((id) => id.trim())
        .filter(Boolean)
    );
    
    const meiliClient = new MeiliSearch({
      host: MEILI_HOST,
      apiKey: MEILI_API_KEY,
    });
    
    const sanitizeFilename = (text) => {
      return text.replace(/[<>:"/\\|?*]/g, '');
    };
    
    const generateFilename = (title, authors) => {
      let authorStr = 'Desconocido';
      if (Array.isArray(authors) && authors.length > 0) {
        authorStr = authors[0];
      } else if (typeof authors === 'string' && authors.length > 0) {
        authorStr = authors;
      }
      const sanitizedTitle = sanitizeFilename(title);
      const sanitizedAuthor = sanitizeFilename(authorStr);
      return `${sanitizedTitle} - ${sanitizedAuthor}.epub`;
    };
    
    const truncate = (text, maxLength = 280) => {
      if (!text || text.length <= maxLength) return text || '';
      return text.substring(0, maxLength - 3) + '...';
    };
    
    const formatResult = (hit) => {
      const authors = Array.isArray(hit.authors) ? hit.authors.join(', ') : hit.authors || 'Desconocido';
      const year = hit.published ? `(${hit.published})` : '';
      const description = truncate(hit.description, 280);
      
      return `${hit.title} ${year}\nAutor: ${authors}\n\n${description}`;
    };
    
    const buildInlineKeyboard = (results) => {
      const keyboard = results.map((hit, index) => ([
        {
          text: `ðŸ“¥ ${index + 1}. ${truncate(hit.title, 40)}`,
          callback_data: `download_${hit.libid}`
        },
        {
          text: 'â„¹ï¸ Info',
          callback_data: `info_${hit.libid}`
        }
      ]));
      
      return { inline_keyboard: keyboard };
    };
    
    const searchMeilisearch = async (query, limit = 5) => {
      try {
        const index = meiliClient.index(MEILI_INDEX);
        const search = await index.search(query, {
          limit,
          attributesToRetrieve: ['libid', 'title', 'authors', 'description', 'published', 'filename'],
        });
        
        return search.hits;
      } catch (err) {
        logger.error({ err, query }, 'Error searching Meilisearch');
        throw err;
      }
    };
    
    const getBookById = async (libid) => {
      try {
        const index = meiliClient.index(MEILI_INDEX);
        const result = await index.getDocument(String(libid), {
          fields: ['libid', 'title', 'authors', 'description', 'published', 'filename', 'pagecount', 'size', 'labels']
        });
        return result;
      } catch (err) {
        logger.error({ err, libid }, 'Error getting book by ID');
        return null;
      }
    };
    
    async function startBot() {
      const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });
      logger.info('Bot connected to Telegram');
      
      bot.on('message', async (msg) => {
        const chatId = msg.chat.id;
        const userId = msg.from?.id ? String(msg.from.id) : '';
        
        if (allowedUsers.size && !allowedUsers.has(userId)) {
          logger.warn({ userId }, 'Unauthorized user');
          return;
        }
        
        const text = msg.text?.trim();
        if (!text) {
          bot.sendMessage(chatId, 'Por favor, envÃ­a un texto para buscar libros.');
          return;
        }
        
        if (text.startsWith('/')) {
          if (text === '/start') {
            bot.sendMessage(chatId, 'ðŸ“š Â¡Hola! Soy el buscador de la Biblioteca Secreta.\n\nEnvÃ­a el tÃ­tulo o autor de un libro y buscarÃ© en la biblioteca local de 152,080 EPUBs.');
          } else if (text === '/help') {
            bot.sendMessage(chatId, 'ðŸ“š Biblioteca Secreta Bot\n\nâ€¢ EnvÃ­a un texto para buscar libros\nâ€¢ Usa los botones para descargar o ver mÃ¡s info\nâ€¢ Resultados limitados a 5 por bÃºsqueda\nâ€¢ Los EPUBs se envÃ­an como archivos (funciona desde cualquier red)');
          } else {
            bot.sendMessage(chatId, 'Comando no reconocido. EnvÃ­a un texto para buscar libros.');
          }
          return;
        }
        
        try {
          logger.info({ chatId, text }, 'Searching for books');
          const results = await searchMeilisearch(text);
          
          if (results.length === 0) {
            bot.sendMessage(chatId, `ðŸ” No encontrÃ© resultados para "${text}".\n\nIntenta con otro tÃ©rmino de bÃºsqueda.`);
            return;
          }
          
          const messageText = `ðŸ“š Resultados para "${text}":\n\n` +
            results.map((hit, i) => `${i + 1}. ${formatResult(hit)}`).join('\n\n---\n\n');
          
          await bot.sendMessage(chatId, messageText, {
            disable_web_page_preview: true,
            reply_markup: buildInlineKeyboard(results)
          });
        } catch (err) {
          logger.error({ chatId, err }, 'Error processing search');
          bot.sendMessage(chatId, `âŒ Error al buscar: ${err.message}`);
        }
      });
      
      bot.on('callback_query', async (query) => {
        const chatId = query.message.chat.id;
        const userId = query.from?.id ? String(query.from.id) : '';
        
        if (allowedUsers.size && !allowedUsers.has(userId)) {
          bot.answerCallbackQuery(query.id, { text: 'No autorizado' });
          return;
        }
        
        try {
          if (query.data.startsWith('download_')) {
            const libid = query.data.replace('download_', '');
            const book = await getBookById(libid);
            
            if (!book || !book.filename) {
              bot.answerCallbackQuery(query.id, { text: 'Libro no encontrado' });
              return;
            }
            
            const downloadUrl = `${BIBLIOTECA_BASE_URL}/biblioteca/${book.filename}`;

            logger.info({ libid, filename: book.filename, title: book.title, authors: book.authors }, 'Sending EPUB from NAS...');
            
            try {
              const response = await fetch(downloadUrl);
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
              }
              const arrayBuffer = await response.arrayBuffer();
              const buffer = Buffer.from(arrayBuffer);
              const filename = generateFilename(book.title, book.authors);
              
              // Crear directorio temporal
              if (!fs.existsSync('/tmp')) {
                fs.mkdirSync('/tmp');
              }
              
              // Escribir archivo temporal
              const tempPath = `/tmp/${filename}`;
              fs.writeFileSync(tempPath, buffer);
              
              logger.info({ libid, filename }, 'Archivo temporal guardado');
              
              // Enviar archivo temporal
              await bot.sendDocument(chatId, tempPath, {
                caption: `ðŸ“¥ ${book.title}\nâœï¸ ${Array.isArray(book.authors) ? book.authors.join(', ') : book.authors}`,
              });
              
              bot.answerCallbackQuery(query.id, { text: 'âœ… Archivo temporal enviado' });
            } catch (fetchError) {
              logger.error({ err: fetchError, url: downloadUrl }, 'Error downloading or saving EPUB');
              bot.sendMessage(chatId, `âŒ Error al descargar o guardar archivo temporal: ${fetchError.message}`);
              bot.answerCallbackQuery(query.id, { text: 'âŒ Error al descargar o guardar' });
            }
          } else if (query.data.startsWith('info_')) {
            const libid = query.data.replace('info_', '');
            const book = await getBookById(libid);

            if (!book) {
              bot.answerCallbackQuery(query.id, { text: 'Libro no encontrado' });
              return;
            }

            const authors = Array.isArray(book.authors) ? book.authors.join(', ') : book.authors || 'Desconocido';
            const labels = Array.isArray(book.labels) ? book.labels.join(', ') : book.labels || 'N/A';
            const downloadUrl = `${BIBLIOTECA_BASE_URL}/biblioteca/${book.filename}`;

            const infoText = `ðŸ“– Detalles del libro\n\n` +
              `ðŸ“š TÃ­tulo: ${book.title}\n` +
              `âœï¸ Autor(es): ${authors}\n` +
              `ðŸ“… AÃ±o: ${book.published || 'N/A'}\n` +
              `ðŸ“„ PÃ¡ginas: ${book.pagecount || 'N/A'}\n` +
              `ðŸ’¾ TamaÃ±o: ${book.size ? `${(book.size / 1024 / 1024).toFixed(2)} MB` : 'N/A'}\n` +
              `ðŸ·ï¸ Etiquetas: ${labels}\n\n` +
              `ðŸ“¥ ${downloadUrl}`;

            await bot.sendMessage(chatId, infoText, {
              disable_web_page_preview: true
            });
            bot.answerCallbackQuery(query.id, { text: 'â„¹ï¸ Detalles mostrados' });
          }
        } catch (err) {
          logger.error({ chatId, err }, 'Error processing callback query');
          bot.answerCallbackQuery(query.id, { text: 'Error al procesar' });
        }
      });
      
      bot.on('polling_error', (err) => {
        logger.warn({ err }, 'Polling error');
      });
      
      logger.info('Bot ready to receive messages');
    }
    
    startBot().catch((err) => {
      logger.error({ err }, 'Bot failed to start');
      process.exit(1);
    });
